# 9. 回文数：字符串法和巧妙解法

---
tag:
- math
---

## 题目链接

https://leetcode-cn.com/problems/palindrome-number/


## 方法一：字符串法（题目要求不能使用此方法）

看到题目要求不能使用此方法，我就特别想用一下。首先将数字转为字符串，之后将字符串的首位与末尾进行比较，一个 `n` 位的数字，最多需要比较 `n/2` 次。

```js
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    let intToStr = x.toString();
    for (let i = 0; i < intToStr.length / 2; i++) {
        if(intToStr[i] !== intToStr[intToStr.length - 1 - i]){
            return false;
        }
    }
    return true;
};
```

- 时间复杂度：O(log(n))
- 空间复杂度：O(n)


## 方法二：巧妙解法

看到这个题目，我们可以想到像方法一那样将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。

我们还可以将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。但是，如果反转后的数字大于 `int.MAX`，我们将遇到整数溢出问题。

但仔细想想，我们可以只反转 `int` 数字的一半，来避免溢出的问题，因为如果该数字是回文，他后半部分反转后应该与原始数字的前半部分相同。

例如，输入 `1221`，我们可以将数字 `1221` 的后半部分从 `21` 反转为 `12`，并将其与前半部分 `12` 进行比较，因为二者相同，我们得知数字 `1221` 是回文。

接下来我们捋顺一下算法步骤：

1. 首先，我们应该处理一些临界情况。所有负数都不可能是回文，如果一个数字的最后一位为 `0`，且这个数是非 `0` 数字，那么它也不可能是回文数，因为非 `0` 数字的首位数字肯定不是 `0`。
2. 现在考虑如何反转后半部分的数字。以数字 `1221` 为例，如果执行 `1221 % 10`，我们将得到最后一位数字 `1`，要得到倒数第二位数字，我们可以先通过除以 `10` 把最后一位数字从 `1221` 中移除，`1221 / 10 = 122`，再求出上一步结果除以 `10` 的余数， `122 % 10 = 2`，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 `10`，再加上倒数第二位数字，`1 * 10 + 2 = 12`，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。

现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？

我们将原始数字除以 `10`，然后给反转后的数字乘上 `10`，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。

```js
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    if (x < 0 || x % 10 === 0 && x !== 0) {
        return false;
    }
    
    let revertedNumber = 0;
    while (x > revertedNumber) {
        revertedNumber = revertedNumber * 10 + x % 10;
        x = Math.floor(x / 10);
    }
    
    // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。
    // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，
    // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。
    return x === revertedNumber || x === Math.floor(revertedNumber / 10);
};
```

- 时间复杂度：O(log(n))
- 空间复杂度：O(1)

<disqus />
